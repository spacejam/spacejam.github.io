<html>
	<head>
		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section data-background-image="images/eiffel-tower.jpg" data-background-size="cover">
          <div style="color: #F00; -webkit-text-stroke: 1px black;">
            RELIABLE INFRASTRUCTURE
          </div>
        </section>
        <section data-background-image="images/eiffel-tower.jpg" data-background-size="cover">
          <div style="color: #F00; -webkit-text-stroke: 1px black;">
            THE CLEAR EXPRESSION OF REALISTIC BELIEFS THROUGH CODE
          </div>
        </section>
				<section data-background-color="#000000">
					<h2>Roadmap</h2>
					<ul>
						<li class="fragment">brains, code, reality</li>
						<li class="fragment">property testing</li>
						<li class="fragment">model-based testing</li>
            <li class="fragment">fault injection</li>
						<li class="fragment">network simulation</li>
						<li class="fragment">optimizing our torture techniques</li>
						<li class="fragment">telling stories to the damned</li>
					</ul>
        </section>
        <section>
          the interplay between brains, code, and reality
        </section>
        <section>
          <h4>property testing</h4>
          <p>problem: the person who writes unit tests brings the same biases to the tests that they brought to the code</p>
          <p></p>
          <p></p>
          <aside class="notes">
          </aside>
        </section>
        <section data-markdown>
          <textarea data-template>
            ```rust
            proptest! {
              #[test]
              fn mult_and_div(ref a in i32::ANY) {
                let result = (a * 5) / 5;
                assert_eq!(result, a);
              }
            }
            ```
          </textarea>
        </section>
        <section>
          output of above
        </section>
        <section>
          replay of above
        </section>
        <section data-markdown>
          <textarea data-template>
            ```rust
            proptest! {
              #[test]
              fn compress_roundtrip(ref s in ".*") {
                let result = decompress(compress(s));
                assert_eq!(result, s);
              }
            }
            ```
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            im-rs has some great examples of using proptest!

            ```rust
            #[test]
            fn lookup(ref m in hash_map(i16::ANY, i16::ANY)) {
                let map: HashMap<i16, i16> = m.iter().collect();
                for (k, v) in m {
                    assert_eq!(Some(v), map.get(k));
                }
            }
            ```
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            crates.rs/crates/<b>im</b>

            ```rust
            #[test]
            fn exact_size_iterator(ref vector in vector(i32::ANY)) {
              let mut should_be = vector.len();
              let mut it = vector.iter();
              loop {
                assert_eq!(should_be, it.len());
                match it.next() {
                  None => break,
                  Some(_) => should_be -= 1,
                }
              }
              assert_eq!(0, it.len());
            }
            ```
          </textarea>
        </section>
        <section>
          <h4>model-based testing</h4>
					<ol>
            <li class="fragment">write a simplified model of a system</li>
            <li class="fragment">generate random sequences of operations on both the implementation and the model</li>
            <li class="fragment">if the model and implementation diverge, try to reduce the operations that caused the failure</li>
            <li class="fragment">turn the failing sequence into a unit test (the machine just wrote a test for you!!!)</li>
            <li class="fragment">either your model is wrong, the implementation is wrong, or both! these are all valuable</li>
          </ol>
          <aside class="notes">
          </aside>
        </section>
        <section data-markdown>
          <textarea data-template>
            crates.rs/crates/<b>model</b>
            ```rust
            model! {
                Model => let mut m = BTreeMap::new(),
                Implementation => let mut i = MyTree::default(),
                Set(k: usize, v: usize) => {
                  assert_eq!(m.insert(k, v), i.set(k, v))
                },
                Get(k: usize) => {
                  assert_eq!(m.get(&k), i.get(&k))
                }
            }
            ```
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            crates.rs/crates/<b>model</b>
            ```rust
            linearizable! {
              Implementation => let i = AtomicUsize::new(0),
              BuggyAdd(usize)(v in 0usize..4) => {
                let current = i.load(Ordering::SeqCst);
                i.store(current + v, Ordering::SeqCst);
                current + v
              }
            }
            ```
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            crates.rs/crates/<b>sparse-bitfield</b>
            ```rust
            proptest! {
              #[test]
              fn doesnt_crash(
                bit in 0usize..1_000_000,
                page_sz_exponent in 0usize..30
              ) {
                let page_sz = 1 << page_sz_exponent;
                let mut bits = Bitfield::new(page_sz);
                assert_eq!(bits.set(bit, true), Change::Changed);
                assert_eq!(bits.get(bit), true);
              }
            }
            ```
          </textarea>
        </section>
        <section>
          <h4>fault injection</h4>
          <ol>
            <li class="fragment">use the </li>
            <li class="fragment"></li>
            <li class="fragment"></li>
            <li class="fragment">gotcha: make sure only one thread is running model-based tests at a time using this!</li>
          </ol>
          <aside class="notes">
          </aside>
        </section>
        <section data-markdown>
          <textarea data-template>
            #### we start handling errors but we don't finish
            ```rust
            if let Err(e) = do_something_with_io() {
              error!("we detected a problem: {}", e);
              // TODO(not me) deal with it!
              panic!(e);
            }
            ```
            Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-intensive Systems (OSDI '14)

            ```
            in 58% of the catastrophic failures, the underlying faults could easily have been detected through simple testing of error handling code.
            ...
            In fact, in 35% of the catastrophic failures, the faults in the error handling code fall into three trivial patterns:"
              * the error handler is simply empty or only contains a log printing statement
              * the error handler aborts the cluster on an overly-general exception
              * the error handler contains expressions like "FIXME" or "TODO" in the comments.
            ```
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            ```rust
            fn do_something_with_io() -> Result<(), ()> {
              fail_point!("might_fail", |_| Err(()));
              Ok(())
            }

            #[test]
            fn test() {
              fail::setup();
              fail::cfg("might_fail", "return").unwrap();

              do_something_with_io().expect_err("should return Err");
            }
            ```
          </textarea>
        </section>
        <section>
          <h4>network simulation</h4>
					<ul>
            <li class="fragment">Jepsen has found bugs in many of the most popular distributed systems</li>
            <li class="fragment">by running a fake network on deterministic components, we can run thousands of partition tests per second</li>
            <li class="fragment">we can have engineers run these tests before opening pull requests in a couple seconds, catching many bugs early</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
        <section data-markdown>
          <textarea data-template>
            ## Simulation

            ```rust

            // Reactor is a trait for building simulable systems.
            pub trait Reactor: Debug + Clone {
                type Peer: std::net::ToSocketAddrs;
                type Message;

                fn receive(
                    &mut self,
                    at: SystemTime,
                    from: Self::Peer,
                    msg: Self::Message,
                ) -> Vec<(Self::Peer, Self::Message)>;
            }
            ```
            github.com/spacejam/quickcheck-tut/caspaxos
          </textarea>
          <aside class="notes">
          </aside>
        </section>
        <section>
          <h4>lineage-driven fault injection</h4>
					<ul>
            <li class="fragment">randomized testing of complex systems can face extremely large search spaces</li>
            <li class="fragment">LDFI observes what goes right without faults, then induces targeted faults starting from the last successful operation</li>
            <li class="fragment">when applied to network simulators, this roots out bugs in distributed algorithms extremely effectively</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
        <section data-markdown>
          <textarea data-template>
            ```rust
            ```
          </textarea>
        </section>
        <section>
					<h2>imposing determinism</h2>
					<ul>
            <li class="fragment">clocks can be controlled externally</li>
            <li class="fragment">random number generators can be seeded externally</li>
            <li class="fragment">threads can be scheduled using linux realtime priorities</li>
            <li class="fragment">files can be wrapped with a mutation log that keeps track of syncs and can be "crashed"</li>
            <li class="fragment">networked systems can be implemented as incoming->[outgoing]</li>
            <li class="fragment">check out this crate: deterministic</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
        <section>
          <h2>misc tips</h2>
					<ul>
            <li class="fragment">try not to use unwrap() everywhere, at least use expect() to speed up debugging</li>
            <li class="fragment">when propagating errors, include context that helps you get back to the root</li>
            <li class="fragment"></li>
					</ul>
          <aside class="notes">
          </aside>
        </section>
        <section data-background-image="images/triumphofdeath.jpg" data-background-size="cover">
          <div style="color: #F00; -webkit-text-stroke: 1px black;">
            THANKS
          </div>
        </section>
			</div>
		</div>
		<script src="js/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/marked.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
      Reveal.initialize({
				transition: 'none',
      });
		</script>
	</body>
</html>
